import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { LogManager, LogLevel } from "../src/utils/loggingUtils";
import { Card } from "../src/models/Card";
import { ApiResponse } from "../src/models/ApiResponse";
import { ImageOptions, ImageSourceStrategy } from "../src/models/Config";
import { getCardCacheKey, formatCacheEntry, parseCacheEntry, getCacheAge } from "../src/utils/cacheUtils";
import { processImageUrls } from "../src/utils/imageUtils";
import { handleError, createNotFoundError } from "../src/utils/errorUtils";
import { CosmosDbService } from "../src/services/CosmosDbService";
import { RedisCacheService } from "../src/services/RedisCacheService";
import { BlobStorageService } from "../src/services/BlobStorageService";
import { PokemonTcgApiService } from "../src/services/PokemonTcgApiService";
import { PokeDataApiService } from "../src/services/PokeDataApiService";

// Initialize services
const cosmosDbService = new CosmosDbService(process.env.COSMOSDB_CONNECTION_STRING || "");
const redisCacheService = new RedisCacheService(
    process.env.REDIS_CONNECTION_STRING || "",
    process.env.ENABLE_REDIS_CACHE === "true"
);
const blobStorageService = new BlobStorageService(
    process.env.BLOB_STORAGE_CONNECTION_STRING || ""
);
const pokemonTcgApiService = new PokemonTcgApiService(
    process.env.POKEMON_TCG_API_KEY || "",
    process.env.POKEMON_TCG_API_BASE_URL
);
const pokeDataApiService = new PokeDataApiService(
    process.env.POKEDATA_API_KEY || "",
    process.env.POKEDATA_API_BASE_URL
);

// Helper function to enrich a card with its PokeData ID using enhanced logging
async function enrichCardWithPokeDataId(cardToEnrich: Card, context: InvocationContext, correlationId: string): Promise<boolean> {
    // Create a logger with the shared correlation ID
    const logger = new LogManager(context, correlationId, LogLevel.DEBUG);
    
    // Create a single point of exit with proper logging
    let success = false;
    
    try {
        logger.info(`ENTER enrichCardWithPokeDataId for card ${cardToEnrich.id} with setCode ${cardToEnrich.setCode}`);
        
        // Get cards in the set from PokeData API using timeOperation for proper tracking
        const pokeDataCards = await logger.timeOperation(
            `Fetch cards for set ${cardToEnrich.setCode}`,
            () => pokeDataApiService.getCardsInSetByCode(cardToEnrich.setCode)
        );
        
        if (pokeDataCards && pokeDataCards.length > 0) {
            logger.info(`Retrieved ${pokeDataCards.length} cards from PokeData API for set ${cardToEnrich.setCode}`);
            
            // Log first few cards for debugging
            if (pokeDataCards.length > 0) {
                logger.debug(`Sample cards: ${JSON.stringify(pokeDataCards.slice(0, 3).map(c => ({id: c.id, num: c.num, name: c.name})))}`);
            }
            
            // Find the matching card by card number
            // Note: Must use exact matching as card numbers in PokeData are formatted exactly (no padding)
            logger.info(`Looking for card with number "${cardToEnrich.cardNumber}" in set`);
            const matchingCard = pokeDataCards.find(
                pdc => pdc.num === cardToEnrich.cardNumber
            );
            
            // If no exact match found, try with leading zeros removed
            // This handles cases where our cardNumber might be "076" but PokeData has "76"
            if (!matchingCard) {
                const trimmedNumber = cardToEnrich.cardNumber.replace(/^0+/, '');
                logger.info(`No exact match found, trying with trimmed number: "${trimmedNumber}"`);
                
                // Log all card numbers in the set for comparison
                const allCardNumbers = pokeDataCards.map(c => c.num).sort();
                logger.debug(`All card numbers in set: ${JSON.stringify(allCardNumbers)}`);
                
                const altMatch = pokeDataCards.find(
                    pdc => pdc.num === trimmedNumber
                );
                
                if (altMatch) {
                    logger.info(`Found card with trimmed number "${trimmedNumber}" instead of "${cardToEnrich.cardNumber}". Card details: ${JSON.stringify({id: altMatch.id, name: altMatch.name, num: altMatch.num})}`);
                    cardToEnrich.pokeDataId = altMatch.id;
                    success = true;
                    await logger.flush();
                    return true;
                } else {
                    logger.warn(`No match found even with trimmed number "${trimmedNumber}"`);
                }
            }
            
            if (matchingCard) {
                logger.info(`Found matching PokeData card: ${matchingCard.name} with ID: ${matchingCard.id}`);
                cardToEnrich.pokeDataId = matchingCard.id;
                success = true;
                await logger.flush();
                return true;
            } else {
                logger.warn(`No matching card found for number ${cardToEnrich.cardNumber} in set ${cardToEnrich.setCode}`);
            }
        } else {
            logger.warn(`No cards returned from PokeData API for set ${cardToEnrich.setCode}`);
        }
    } catch (error: any) {
        logger.error(`Error enriching card with PokeData ID: ${error.message}`);
        logger.error(`Error stack: ${error.stack}`);
        
        // If there's a response object, log that too
        if (error.response) {
            logger.error(`Error response status: ${error.response.status}`);
            logger.error(`Error response data: ${JSON.stringify(error.response.data)}`);
        }
    }
    
    // Log exit and return the success status
    logger.info(`EXIT enrichCardWithPokeDataId, result: ${success}`);
    await logger.flush();
    return success;
}

// Helper function to check if pricing data is stale
function isPricingStale(timestamp: string): boolean {
    if (!timestamp) return true;
    
    const lastUpdate = new Date(timestamp).getTime();
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    
    return (now - lastUpdate) > oneDayMs;
}

// Helper function to log card state for debugging using enhanced logging
function logCardState(card: Card, stage: string, context: InvocationContext, correlationId: string): void {
    // Create a logger with the shared correlation ID
    const logger = new LogManager(context, correlationId, LogLevel.DEBUG);
    
    logger.info(`CARD STATE at ${stage}: ${JSON.stringify({
        id: card.id,
        setCode: card.setCode,
        cardNumber: card.cardNumber,
        pokeDataId: card.pokeDataId,
        hasPricing: !!card.pricing,
        pricingCount: card.pricing ? Object.keys(card.pricing).length : 0,
        pricingLastUpdated: card.pricingLastUpdated,
        hasEnhancedPricing: !!card.enhancedPricing,
        enhancedPricingKeys: card.enhancedPricing ? Object.keys(card.enhancedPricing) : [],
        enhancedPricingCount: card.enhancedPricing ? Object.keys(card.enhancedPricing).length : 0
    })}`);
    
    // Flush logs to ensure they're captured
    // We're not awaiting this since logCardState is a synchronous function
    // But the flush will still happen asynchronously
    logger.flush().catch(err => {
        context.log(`Error flushing logs: ${err.message}`);
    });
}

export async function getCardInfo(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    // Generate a correlation ID for request tracking
    const correlationId = `card-${request.params.cardId || 'unknown'}-${Date.now()}`;
    
    // Create an enhanced logger with high log level to capture all details
    const logger = new LogManager(context, correlationId, LogLevel.DEBUG);
    
    // Log environment configuration
    logger.info(`CONFIGURATION:
    ENABLE_REDIS_CACHE: ${process.env.ENABLE_REDIS_CACHE}
    CACHE_TTL_CARDS: ${process.env.CACHE_TTL_CARDS}
    IMAGE_SOURCE_STRATEGY: ${process.env.IMAGE_SOURCE_STRATEGY}
    ENABLE_CDN_IMAGES: ${process.env.ENABLE_CDN_IMAGES}
    POKEDATA_API_BASE_URL: ${process.env.POKEDATA_API_BASE_URL?.substring(0, 20)}...
`);
    
    try {
        // Start timing the request
        const startTime = Date.now();
        
        // Get card ID from route parameters
        const cardId = request.params.cardId;
        
        if (!cardId) {
            const errorResponse = createNotFoundError("Card ID", "missing", "GetCardInfo");
            logger.error(`Missing card ID in request`);
            
            // Ensure logs are flushed before returning
            await logger.flush();
            
            return {
                jsonBody: errorResponse,
                status: errorResponse.status
            };
        }
        
        logger.info(`Processing request for card: ${cardId}`);
        
        // Parse query parameters
        const forceRefresh = request.query.get("forceRefresh") === "true";
        // Ensure cardsTtl is a valid number
        let cardsTtl: number = 86400; // 24 hours default
        try {
            const ttlFromEnv = parseInt(process.env.CACHE_TTL_CARDS || "86400");
            cardsTtl = !isNaN(ttlFromEnv) ? ttlFromEnv : 86400;
        } catch (e: any) {
            logger.warn(`Error parsing CACHE_TTL_CARDS, using default: ${e.message}`);
        }
        
        // Check Redis cache first (if enabled and not forcing refresh)
        const cacheKey = getCardCacheKey(cardId);
        let card: Card | null = null;
        let cacheHit = false;
        let cacheAge = 0;
        
        if (!forceRefresh && process.env.ENABLE_REDIS_CACHE === "true") {
            const cacheStartTime = Date.now();
            const cachedEntry = await redisCacheService.get<{ data: Card; timestamp: number; ttl: number }>(cacheKey);
            const cacheEndTime = Date.now();
            logger.debug(`Redis cache lookup completed in ${cacheEndTime - cacheStartTime}ms`);
            
            card = parseCacheEntry<Card>(cachedEntry);
            
            if (card) {
                logger.info(`Cache hit for card: ${cardId}`);
                cacheHit = true;
                // Ensure cachedEntry is not null before calling getCacheAge
                if (cachedEntry) {
                    cacheAge = getCacheAge(cachedEntry.timestamp);
                    logger.info(`Cache entry age: ${cacheAge} seconds (${Math.round(cacheAge/3600)} hours)`);
                }
            }
        }
        
        // If not in cache, check Cosmos DB
        if (!card) {
            logger.info(`Cache miss for card: ${cardId}, checking database`);
            const dbStartTime = Date.now();
            card = await logger.timeOperation(
                "Cosmos DB lookup", 
                () => cosmosDbService.getCard(cardId)
            );
            const dbEndTime = Date.now();
            logger.info(`Database lookup completed in ${dbEndTime - dbStartTime}ms, found: ${!!card}`);
            
            // If not in database, fetch from external API
            if (!card) {
                logger.info(`Card not found in database, fetching from Pokemon TCG API: ${cardId}`);
                
                // Use timeOperation for proper tracking
                card = await logger.timeOperation(
                    "Pokemon TCG API lookup", 
                    () => pokemonTcgApiService.getCard(cardId)
                );
                
                // If card found, save to database
                if (card) {
                    logger.info(`Card found in Pokemon TCG API, saving to database`);
                    
                    // Use timeOperation for database save operation
                    await logger.timeOperation(
                        "Save card to database",
                        () => cosmosDbService.saveCard(card)
                    );
                    
                    // Log the initial state of the card
                    logCardState(card, "INITIAL_FROM_TCG_API", context, correlationId);
                }
            }
        }
        
        // Now that we have the card (from cache, DB, or API), check for enrichment
        if (card) {
            // Log card state before enrichment using our helper
            logCardState(card, "BEFORE_ENRICHMENT", context, correlationId);
            
            let cardUpdated = false;
            
            // Evaluate and log all condition results
            const condition1 = !card.pokeDataId;
            const condition2 = card.pokeDataId && (forceRefresh || !card.pricing || !card.pricingLastUpdated || isPricingStale(card.pricingLastUpdated));
            const condition3 = card.pokeDataId && (!card.enhancedPricing || Object.keys(card.enhancedPricing || {}).length === 0);
            
            logger.info(`Enrichment condition evaluations:`);
            logger.info(`- condition1 (!card.pokeDataId): ${condition1}`);
            
            if (condition2) {
                logger.info(`- condition2 breakdown: forceRefresh=${forceRefresh}, !card.pricing=${!card.pricing}, !card.pricingLastUpdated=${!card.pricingLastUpdated}, isPricingStale=${card.pricingLastUpdated ? isPricingStale(card.pricingLastUpdated) : 'N/A'}`);
                if (card.pricingLastUpdated) {
                    const lastUpdate = new Date(card.pricingLastUpdated).getTime();
                    const now = Date.now();
                    const oneDayMs = 24 * 60 * 60 * 1000;
                    logger.info(`- pricingLastUpdated: ${card.pricingLastUpdated}, age: ${(now - lastUpdate) / oneDayMs} days`);
                }
            }
            
            logger.info(`- condition3 (missing enhanced pricing): ${condition3}`);
            if (condition3) {
                logger.info(`- enhancedPricing check: enhancedPricing exists=${!!card.enhancedPricing}, keys count=${card.enhancedPricing ? Object.keys(card.enhancedPricing).length : 0}`);
            }
            
            if (card.enhancedPricing) {
                logger.info(`Enhanced pricing keys: ${Object.keys(card.enhancedPricing).join(', ')}`);
                logger.info(`Enhanced pricing size: ${Object.keys(card.enhancedPricing).length}`);
                
                // If there are any keys, log a sample of the data
                const keys = Object.keys(card.enhancedPricing);
                if (keys.length > 0) {
                    const sampleKey = keys[0];
                    // Use a type assertion to tell TypeScript this is valid
                    const sampleData = (card.enhancedPricing as any)[sampleKey];
                    logger.info(`Sample enhanced pricing data for key ${sampleKey}: ${JSON.stringify(sampleData)}`);
                }
            }
            
            // Check if card needs PokeData ID
            if (!card.pokeDataId) {
                logger.info(`Card ${cardId} missing PokeData ID, attempting to find it`);
                const enrichStartTime = Date.now();
                const enrichResult = await enrichCardWithPokeDataId(card, context, correlationId);
                const enrichEndTime = Date.now();
                logger.info(`PokeData ID enrichment completed in ${enrichEndTime - enrichStartTime}ms with result: ${enrichResult}`);
                
                if (enrichResult) {
                    logger.info(`Successfully added PokeData ID: ${card.pokeDataId} to card ${cardId}`);
                    cardUpdated = true;
                    
                    // If we now have a pokeDataId, we can fetch pricing
                    // Ensure pokeDataId is not undefined
                    if (card.pokeDataId) {
                        logger.info(`Fetching pricing data for newly found PokeData ID: ${card.pokeDataId}`);
                        const pricingStartTime = Date.now();
                        const freshPricing = await pokeDataApiService.getCardPricingById(card.pokeDataId);
                        const pricingEndTime = Date.now();
                        logger.info(`Pricing data fetch completed in ${pricingEndTime - pricingStartTime}ms, pricing found: ${!!freshPricing}`);
                        
                        if (freshPricing) {
                            logger.info(`Retrieved pricing data for PokeData ID: ${card.pokeDataId}`);
                            card.pricing = freshPricing;
                            card.pricingLastUpdated = new Date().toISOString();
                            const enhancedPricing = pokeDataApiService['mapApiPricingToEnhancedPriceData']({ pricing: freshPricing });
                            card.enhancedPricing = enhancedPricing || undefined;
                        } else {
                            logger.warn(`No pricing data available for PokeData ID: ${card.pokeDataId}`);
                        }
                    }
                } else {
                    logger.warn(`Failed to find PokeData ID for card ${cardId}`);
                }
            }
            // Check if card has PokeData ID but needs pricing refresh
            else if (condition2) {
                logger.info(`Entering condition2 branch (needs pricing refresh)`);
                logger.info(`Card has PokeData ID ${card.pokeDataId} but needs pricing refresh`);
                
                // Get pricing directly using the PokeData ID
                const pricingStartTime = Date.now();
                const freshPricing = await logger.timeOperation(
                    `Get pricing data for PokeData ID ${card.pokeDataId}`,
                    () => pokeDataApiService.getCardPricingById(card.pokeDataId)
                );
                const pricingEndTime = Date.now();
                logger.info(`Pricing data fetch completed in ${pricingEndTime - pricingStartTime}ms, pricing found: ${!!freshPricing}`);
                
                if (freshPricing) {
                    // Update the card's pricing data
                    card.pricing = freshPricing;
                    card.pricingLastUpdated = new Date().toISOString();
                    
                    // For backward compatibility - convert null to undefined if needed
                    const enhancedPricing = pokeDataApiService['mapApiPricingToEnhancedPriceData']({ pricing: freshPricing });
                    card.enhancedPricing = enhancedPricing || undefined;
                    
                    cardUpdated = true;
                    logger.info(`Updated card ${cardId} with fresh pricing data`);
                    
                    // Log the updated card state after pricing refresh
                    logCardState(card, "AFTER_PRICING_REFRESH", context, correlationId);
                } else {
                    logger.warn(`Failed to fetch pricing data for PokeData ID: ${card.pokeDataId}`);
                }
            }
            // Check if card has PokeData ID but is missing enhanced pricing data
            else if (condition3) {
                logger.info(`Entering condition3 branch (missing enhanced pricing)`);
                logger.info(`Card has PokeData ID ${card.pokeDataId} but is missing enhanced pricing data`);
                
                // Get pricing directly using the PokeData ID
                const pricingStartTime = Date.now();
                const freshPricing = await logger.timeOperation(
                    `Get enhanced pricing data for PokeData ID ${card.pokeDataId}`,
                    () => pokeDataApiService.getCardPricingById(card.pokeDataId)
                );
                const pricingEndTime = Date.now();
                logger.info(`Pricing data fetch completed in ${pricingEndTime - pricingStartTime}ms, pricing found: ${!!freshPricing}`);
                
                if (freshPricing) {
                    // Update the card's pricing data
                    card.pricing = freshPricing;
                    card.pricingLastUpdated = new Date().toISOString();
                    
                    // For backward compatibility - convert null to undefined if needed
                    const enhancedPricing = pokeDataApiService['mapApiPricingToEnhancedPriceData']({ pricing: freshPricing });
                    card.enhancedPricing = enhancedPricing || undefined;
                    
                    cardUpdated = true;
                    logger.info(`Added enhanced pricing data to card ${cardId}`);
                    
                    // Log the updated card state after pricing refresh
                    logCardState(card, "AFTER_ENHANCED_PRICING_ADDED", context, correlationId);
                } else {
                    logger.warn(`Failed to fetch enhanced pricing data for PokeData ID: ${card.pokeDataId}`);
                }
            } else {
                logger.info(`No enrichment conditions were met, card already has all data`);
            }
            
            // Save the updated card to database if changes were made
            if (cardUpdated) {
                logger.info(`Saving updated card to database`);
                await logger.timeOperation(
                    "Save updated card to database",
                    () => cosmosDbService.updateCard(card)
                );
                
                // Update cache if enabled
                if (process.env.ENABLE_REDIS_CACHE === "true") {
                    logger.info(`Updating card in cache`);
                    // Use a hardcoded number for the ttl parameter
                    await logger.timeOperation(
                        "Update Redis cache",
                        async () => {
                            await redisCacheService.set(
                                cacheKey, 
                                formatCacheEntry(card, 86400), 
                                86400
                            );
                        }
                    );
                }
            }
            
            // Process image URLs
            const imageOptions: ImageOptions = {
                cdnEndpoint: process.env.CDN_ENDPOINT || "",
                sourceStrategy: (process.env.IMAGE_SOURCE_STRATEGY || "hybrid") as ImageSourceStrategy,
                enableCdn: process.env.ENABLE_CDN_IMAGES === "true"
            };
            
            card = await processImageUrls(card, {
                ...imageOptions,
                blobStorageService
            });
            
            // Prepare the response
            const response: ApiResponse<Card> = {
                status: 200,
                data: card,
                timestamp: new Date().toISOString(),
                cached: cacheHit,
                cacheAge: cacheHit ? cacheAge : 0
            };
            
            // Create the HTTP response to return
            const httpResponse = { 
                jsonBody: response,
                status: response.status,
                headers: {
                    "Cache-Control": `public, max-age=86400`
                }
            };
            
            // Log the total function execution time
            const endTime = Date.now();
            logger.info(`Function completed in ${endTime - startTime}ms`);
            
            // Ensure all logs are flushed before returning
            await logger.flush();
            
            return httpResponse;
        } else {
            // If we couldn't find the card after all lookups
            const errorResponse = createNotFoundError("Card", cardId, "GetCardInfo");
            
            // Ensure logs are flushed before returning
            await logger.flush();
            
            return {
                jsonBody: errorResponse,
                status: errorResponse.status
            };
        }
    } catch (error: any) {
        // Log the error with our enhanced logger
        logger.error(`Error in getCardInfo: ${error.message}`);
        if (error.stack) {
            logger.error(`Stack trace: ${error.stack}`);
        }
        
        // Create the error response
        const errorResponse = handleError(error, "GetCardInfo");
        
        // Ensure all logs are flushed before returning
        await logger.flush();
        
        return {
            jsonBody: errorResponse,
            status: errorResponse.status
        };
    }
}

app.http('getCardInfo', {
    methods: ['GET'],
    authLevel: 'function',
    route: 'cards/{cardId}',
    handler: getCardInfo
});

